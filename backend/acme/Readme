# ACME â€” Address Computation for Memory Encoding

This folder contains the ACME engine for converting FPGA region
coordinates (e.g., CLOCKREGION_X1Y2:CLOCKREGION_X1Y3) into specific
configuration bit addresses (LFAs) that the SEM controller understands.

## Philosophy

**ACME is a tool, not a setup step.**

Area profiles call ACME functions directly when they need to expand
pblock coordinates into addresses. No global engine needs to be created
at startup. ACME engines are created on-demand and discarded after use.

## Public API

Located in `fi/targets/acme_sem_decoder.py`:
```python
from fi.targets.acme_sem_decoder import expand_pblock_to_config_bits

# Convert region to list of addresses
addresses = expand_pblock_to_config_bits(
    region="CLOCKREGION_X1Y2:CLOCKREGION_X1Y3",
    board_name="basys3",
    ebd_path="fi/backend/acme/design.ebd"
)
# Returns: ["00001234", "00001236", ...]
```

For device-wide expansion:
```python
from fi.targets.acme_sem_decoder import expand_device_to_config_bits

addresses = expand_device_to_config_bits(
    full_device_region="CLOCKREGION_X0Y0:CLOCKREGION_X3Y3",
    board_name="basys3",
    ebd_path="fi/backend/acme/design.ebd"
)
```

## Architecture

### Internal Components (fi/backend/acme/)

- **Board models**: `basys3.py`, `xcku040.py` - Device-specific parameters
- **EBD parser**: Reads essential bits database files
- **ACME engine**: Implements address computation equations
- **Caching**: Optional result caching for performance

### External Interface (fi/targets/)

- **acme_sem_decoder.py**: Clean API for area profiles
  - Creates engine on-demand
  - Handles errors gracefully
  - Returns addresses as hex strings
  - No global state

## How It Works

1. Area profile calls `expand_pblock_to_config_bits()`
2. Function creates ACME engine for specified board
3. Engine loads EBD file and device parameters
4. Region coordinates are converted to frame addresses
5. Frame addresses are expanded to individual bit addresses
6. Addresses returned as list of hex strings
7. Engine is discarded (no persistent state)

## Adding Support for New Boards

To add a new FPGA device:

1. **Create board model** in `fi/backend/acme/` (e.g., `zynq7.py`):
```python
   # Device parameters
   DEVICE_NAME = "zynq7"
   CLOCK_REGIONS_X = 4
   CLOCK_REGIONS_Y = 3
   # ... frame layout, bit counts, etc.
   
   def compute_frame_address(x, y, frame_type):
       # Implement address equation for this device
       ...
```

2. **Register in `fi/backend/acme/__init__.py`**:
```python
   BOARD_MODELS = {
       "basys3": basys3,
       "xcku040": xcku040,
       "zynq7": zynq7,  # NEW
   }
```

3. **Add board entry to SystemDict YAML**:
```yaml
   zynq7:
     full_device_region: "CLOCKREGION_X0Y0:CLOCKREGION_X3Y2"
     registers: [...]
     modules: {...}
```

4. **Provide EBD file** for the device (essential bits database)

## EBD Files

Essential Bits Database (EBD) files describe which configuration bits
are actually used (essential) for a given design. ACME uses these to:

- Filter out unused bits
- Map logical regions to physical frames
- Determine which bits are safe to inject into

EBD files are generated by Vivado and should be placed in `fi/backend/acme/`.
Default path is set in `fi_settings.py` as `DEFAULT_EBD_PATH`.

## Performance Notes

Expanding large regions (e.g., full device) can generate many addresses.
Consider:

- **Caching**: ACME can cache expansion results
- **Sampling**: Device profile supports `sample_size` argument
- **Filtering**: Use specific modules instead of device-wide

## Troubleshooting

**Empty address list returned:**
- Check board_name matches entry in SystemDict
- Verify EBD file exists and is readable
- Check region coordinates are valid for the device
- Look for error logs from ACME engine

**Slow expansion:**
- Enable ACME caching (if implemented)
- Use smaller regions or sampling
- Check EBD file size (very large files are slower to parse)

## Error Handling

ACME functions return empty lists on error rather than raising exceptions.
This allows area profiles to continue gracefully. Always check the logs
for error details:
```python
addresses = expand_pblock_to_config_bits(region, board, ebd)
if not addresses:
    # Check logs for error details
    logger.warning(f"No addresses for region {region}")
```

## No Setup Required

Unlike previous designs, ACME does not require:
- Pre-initialization at startup
- Global engine instances
- Setup functions in fi/core/campaign/

Just call the expansion functions when needed. Each call is independent.