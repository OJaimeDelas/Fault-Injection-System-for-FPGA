# FI Targets — Target Selection and Pools

This folder manages injection target representations, selection strategies,
and pool construction.

## What Are Targets?

In FI, a **target** is a specific location where a fault can be injected:

- **Configuration bit (CONFIG)**: A single bit in the FPGA configuration memory
- **Register (REG)**: A register in the design (identified by reg_id)

Every target reduces to a `TargetSpec` structure with all necessary information
for injection.

## Key Concepts

### SystemDict — Hardware Description

The **system dictionary** is a YAML file that describes the FPGA hardware: device geometry, modules with spatial coordinates, and register definitions.

**Structure:**
```yaml
board_name:              # e.g., xcku040, basys3
  device:                # FPGA geometry for ACME
    min_x, max_x, min_y, max_y, wf
  targets:               # Modules with coordinates and registers
    module_key:
      x_lo, y_lo, x_hi, y_hi
      registers: [list of reg_ids]
      module: "module_name"
  registers:             # Complete register index
    id: {name: "reg_name", module: "module_name"}
```

**See:** Main README (lines 150-230) for complete format details and examples.

**Board Resolution:**
- CLI `--board` argument (explicit)
- Auto-detect if only one board in dictionary
- DEFAULT_BOARD_NAME from fi_settings.py (fallback)

---

### TargetSpec — Unified Target Representation

Every injection target is represented as a `TargetSpec`:
```python
@dataclass
class TargetSpec:
    kind: TargetKind  # CONFIG or REG
    module_name: str  # Which module (for logging/stats)
    
    # For CONFIG kind:
    config_address: str  # LFA hex string (e.g., "00001234")
    pblock_name: str     # Which pblock
    
    # For REG kind:
    reg_id: int          # Register ID number
    reg_name: str        # Human-readable name
    
    # Metadata:
    source: str          # Where this target came from
    tags: tuple          # For filtering/grouping
```

#### TargetKind Enum

The `TargetKind` enum distinguishes between the two target types:

- **CONFIG**: Configuration bit (logic) injection via SEM
- **REG**: Register injection via UART fi_coms protocol

#### Field Validation

`TargetSpec.__post_init__()` validates that:
- CONFIG targets have `config_address`
- REG targets have `reg_id`

This validation happens automatically when creating a TargetSpec:
```python
# Valid CONFIG target
target = TargetSpec(
    kind=TargetKind.CONFIG,
    module_name="alu",
    config_address="00001234",
    pblock_name="alu_pb"
)

# Invalid - missing config_address
target = TargetSpec(
    kind=TargetKind.CONFIG,
    module_name="alu"
)
# Raises: ValueError: CONFIG target must have config_address
```

#### Source Field

The `source` field tracks where the target came from:

- `"profile:modules"` - Generated by modules area profile
- `"profile:device"` - Generated by device area profile
- `"pool:file"` - Loaded from explicit pool YAML
- `"unknown"` - Source not specified

This helps with debugging and understanding pool composition.

#### Tags Field

The `tags` field is a tuple of arbitrary strings for filtering/grouping:
```python
target = TargetSpec(
    kind=TargetKind.CONFIG,
    module_name="alu",
    config_address="00001234",
    tags=("critical", "arithmetic")
)
```

Tags can be used by custom area profiles or analysis tools.

### TargetPool — Ordered Target Collection

A `TargetPool` is a flat, ordered list of `TargetSpec` objects. The pool
represents the complete injection sequence for a campaign.
```python
pool = TargetPool()
pool.add(target1)
pool.add(target2)

# Iterate through pool
while (target := pool.pop_next()) is not None:
    inject(target)

# Get statistics
stats = pool.get_stats()
# {
#   "total": 1000,
#   "by_kind": {"CONFIG": 750, "REG": 250},
#   "by_module": {
#     "alu": {"CONFIG": 250, "REG": 100},
#     "lsu": {"CONFIG": 500, "REG": 150}
#   },
#   "position": 0,
#   "remaining": 1000
# }
```

#### Key Methods

- `add(target)` - Add single target
- `add_many(targets)` - Add multiple targets
- `pop_next()` - Get next target (returns None when exhausted)
- `reset()` - Reset iteration to beginning
- `count_by_kind()` - Count CONFIG vs REG
- `count_by_module()` - Count per-module breakdown
- `get_stats()` - Comprehensive statistics dictionary

#### Iteration Pattern

The `pop_next()` method is the main iteration interface:
```python
# Time profile iterates through pool
while (target := pool.pop_next()) is not None:
    # Route target to appropriate backend
    if target.kind == TargetKind.CONFIG:
        sem_proto.inject(target.config_address)
    elif target.kind == TargetKind.REG:
        board_if.inject_register(target.reg_id)
```

When the pool is exhausted, `pop_next()` returns `None`.

#### Statistics Methods

The pool provides three levels of statistics:

1. **count_by_kind()** - Simple CONFIG/REG breakdown:
```python
   >>> pool.count_by_kind()
   {<TargetKind.CONFIG>: 750, <TargetKind.REG>: 250}
```

2. **count_by_module()** - Per-module breakdown:
```python
   >>> pool.count_by_module()
   {
       'alu': {'CONFIG': 250, 'REG': 100},
       'lsu': {'CONFIG': 500, 'REG': 150}
   }
```

3. **get_stats()** - Everything including position:
```python
   >>> pool.get_stats()
   {
       'total': 1000,
       'by_kind': {'CONFIG': 750, 'REG': 250},
       'by_module': {...},
       'position': 250,  # How many consumed
       'remaining': 750  # How many left
   }
```

### Router — Backend Dispatch

The **router** (`router.py`) is the central dispatch point that sends targets
to the appropriate injection backend based on target kind.

#### Routing Logic
```python
from fi.targets.router import route_target

# Router automatically dispatches based on target.kind
success = route_target(
    target=target,
    sem_proto=sem_proto,    # For CONFIG targets
    board_if=board_if       # For REG targets
)
```

#### Backend Mapping

- **CONFIG targets** → `sem_proto.inject(address)`
  - Routes to SEM IP core via UART
  - Handled by `fi/backend/sem/protocol.py`
  - Injects configuration bits (logic/LUTs/routing)

- **REG targets** → `board_if.inject_register(reg_id)`
  - Routes to board interface (UART fi_coms)
  - Handled by `fi/targets/board_interface.py`
  - Injects faults into flip-flops

#### Error Handling

The router catches exceptions from both backend and returns False on failure:
```python
success = route_target(target, sem_proto, board_if)
if not success:
    # Injection failed - error already logged by router
    handle_failure(target)
```

All errors are logged with details about which backend failed and why.

#### Adding New Backends

To add a new injection backend:

1. Add new `TargetKind` to `types.py`
2. Update `route_target()` to handle new kind
3. Implement new backend module
4. Update relevant area profiles to generate new kind

Example:
```python
# Add to router.py
elif target.kind == TargetKind.CUSTOM:
    return _inject_custom(target, custom_backend)
```

### Pool Files — Explicit Target Lists

Pool files are optional YAML files that specify explicit injection
targets in a pre-determined order.

#### Format

Pool files contain a simple list of fully-specified targets:
```yaml
targets:
  - kind: CONFIG
    module_name: "alu"
    config_address: "00001234"
    pblock_name: "alu_pb"
  
  - kind: REG
    module_name: "decoder"
    reg_id: 5
    reg_name: "dec_rec_q"
  
  - kind: CONFIG
    module_name: "lsu"
    config_address: "00005678"
    pblock_name: "lsu_pb"
```

#### Required Fields

**All targets must have:**
- `kind`: "CONFIG" or "REG"
- `module_name`: Module name (for logging/stats)

**CONFIG targets must have:**
- `config_address`: Hex address string

**REG targets must have:**
- `reg_id`: Integer register ID

#### Optional Fields

- `pblock_name`: Pblock name (CONFIG targets)
- `reg_name`: Human-readable register name (REG targets)

#### Usage

Specify pool file via CLI:
```bash
python -m fi.fault_injection --pool-file my_targets.yaml
```

Or via area profile:
```bash
python -m fi.fault_injection \
    --area target_list \
    --area-args "pool_file=my_targets.yaml"
```

Or load programmatically:
```python
from fi.targets.pool_loader import load_pool_from_file

pool = load_pool_from_file("my_targets.yaml")
if pool is not None:
    print(f"Loaded {len(pool)} targets")
```

#### When to Use Pool Files

Pool files are useful for:

- **Reproducible campaigns**: Same targets every time
- **Custom orderings**: Specific injection sequences
- **External generation**: Targets generated by other tools
- **Debugging**: Test specific target combinations

For dynamic target generation, use area profiles instead
(modules, device, etc.).

#### Important: No Expansion

Pool files contain **explicit TargetSpecs** only. They do NOT support:
- Module expansion
- Pblock expansion
- Wildcard patterns
- Dynamic generation

All targets must be fully specified. If you need expansion, use an
area profile (e.g., `modules` or `device`). Area profiles are responsible
for calling ACME and generating configuration bit addresses.

#### Error Handling

The pool loader is forgiving:
- Missing file → returns None with warning
- Invalid YAML → returns None with error
- Invalid targets → skipped with warnings, rest of file loaded
- Empty file → returns None with error

Example error cases:
```yaml
# Missing 'kind' - skipped
targets:
  - module_name: "alu"
    config_address: "00001234"

# CONFIG without address - skipped
targets:
  - kind: CONFIG
    module_name: "alu"

# REG without reg_id - skipped
targets:
  - kind: REG
    module_name: "decoder"
```

### Design Philosophy

- **Flat pools**: TargetPool is just a list, no hierarchy or selection logic
- **Area profiles build pools**: Profiles are responsible for expanding modules/pblocks
- **Time profiles consume pools**: Profiles iterate through pools via pop_next()
- **Router dispatches**: CONFIG → SEM, REG → UART register injection (determined at injection time)

## Files

- `dict_loader.py`: Load and parse SystemDict from YAML
- `types.py`: TargetSpec and TargetKind definitions
- `pool.py`: TargetPool container class
- `pool_loader.py`: Load explicit pools from YAML files
- `router.py`: Route targets to SEM or UART-based register injection backend
- `acme_sem_decoder.py`: ACME interface for address expansion
- `board_interface.py`: Board-level register injection interface

## SystemDict Loading
```python
from fi.targets.dict_loader import load_system_dict

system_dict = load_system_dict("fi/config/system_dict.yaml")

# Access board data
board_dict = system_dict.boards["xcku040"]
print(f"Full device region: {board_dict.full_device_region}")

# Access modules
for module_name, module_info in board_dict.modules.items():
    print(f"{module_name}: {module_info.description}")
    print(f"  Pblock: {module_info.pblock.region}")
    print(f"  Registers: {module_info.registers}")

# Access registers
for reg_info in board_dict.registers:
    print(f"reg_id={reg_info.reg_id}, name={reg_info.name}")
```

## Board Resolution

Board name resolution follows this priority chain:

1. **CLI explicit**: `--board xcku040`
2. **Auto-detect**: If SystemDict has only one board, use it automatically
3. **Default fallback**: Use DEFAULT_BOARD_NAME from fi_settings.py
4. **Error**: If none of the above work, raise clear error

Example:
```python
from fi.engine.board_resolution import resolve_board_name

board_name = resolve_board_name(cfg, system_dict)
# Returns: "xcku040" (depending on resolution chain)
```

## Injection Flow

Complete injection flow from area profile to hardware:
```
┌─────────────────┐
│  Area Profile   │ Builds TargetPool (modules, device, etc.)
└────────┬────────┘
         │ TargetPool (ordered list of TargetSpecs)
         ▼
┌─────────────────┐
│  Time Profile   │ Consumes pool via pop_next()
└────────┬────────┘
         │ TargetSpec
         ▼
┌─────────────────┐
│ Injection       │ controller.inject_target(target)
│ Controller      │
└────────┬────────┘
         │ TargetSpec
         ▼
┌─────────────────┐
│     Router      │ Dispatches based on target.kind
└────┬────────┬───┘
     │        │
     │ CONFIG │ REG
     ▼        ▼
┌─────────┐ ┌───────────────┐
│   SEM   │ │ Board         │
│ Protocol│ │ Interface     │
│ (UART)  │ │ (UART fi_coms)│
└─────────┘ └───────────────┘
     │              │
     ▼              ▼
┌─────────┐ ┌──────────────┐
│ SEM IP  │ │ FPGA         │
│  Core   │ │ (Registers)  │
└─────────┘ └──────────────┘
```

Each layer has a clear responsibility:
- **Area profiles**: Build target pools (WHERE to inject)
- **Time profiles**: Schedule injections (WHEN to inject)
- **Controller**: Orchestrate injection process
- **Router**: Dispatch to correct backend (HOW to inject)
- **Backends**: Physical injection (SEM/UART register injection)

---

## Related Documentation

### Core Systems
- [Main README](../Readme.md) - System overview, target system section
- [Config System](../core/config/Readme.md) - Configuration management
- [Campaign Controller](../core/campaign/Readme.md) - Consumes TargetPool

### Backends
- [Backend Overview](../backend/Readme.md) - Where targets are routed
- [SEM Backend](../backend/sem/Readme.md) - CONFIG target injection
- [Register Injection](../backend/reg_inject/Readme.md) - REG target injection

### Profiles
- [Profile Overview](../profiles/Readme.md) - Profile system
- [Area Profiles](../profiles/area/Readme) - Build TargetPool
- [Time Profiles](../profiles/time/Readme) - Consume targets via controller

### See Also
- `fi_settings.py` - TPOOL_DEFAULT_SIZE
- `types.py` - TargetSpec and TargetKind definitions
- `pool.py` - TargetPool implementation
- `router.py` - Target routing to backends
- `dict_loader.py` - System dictionary loading
- Target pool export in main README