# =============================================================================
# FATORI-V â€¢ FI Targets Pool Writer
# File: pool_writer.py
# -----------------------------------------------------------------------------
# Write TargetPool to YAML file for reproducibility and debugging.
#=============================================================================

from pathlib import Path
from typing import Optional, Dict
import datetime
import shutil
import logging

from fi.targets.pool import TargetPool

logger = logging.getLogger(__name__)

DEFAULT_OUTPUT_DIR = Path("fi/gen/tpool")


def generate_pool_filename(custom_name: Optional[str], profile_name: str) -> str:
    """
    Generate filename for pool YAML file.
    
    Uses custom name if provided, otherwise generates timestamped filename.
    
    Args:
        custom_name: User-provided filename (without extension), or None
        profile_name: Name of area profile that generated the pool
    
    Returns:
        Filename with .yaml extension
    """
    if custom_name:
        # Sanitize custom name - keep only alphanumerics, hyphens, underscores
        safe_name = "".join(c for c in custom_name if c.isalnum() or c in "-_")
        if not safe_name:
            # Fallback if sanitization removed everything
            safe_name = "pool"
        return f"{safe_name}.yaml"
    else:
        # Generate timestamp-based filename
        # Format: YYYYMMDD_HHMMSS_profile.yaml (e.g., 20250126_153045_modules.yaml)
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"{timestamp}_{profile_name}.yaml"


def write_pool_to_yaml(
    pool: TargetPool,
    output_dir: Path,
    filename: str,
    metadata: Optional[Dict[str, str]] = None
) -> Path:
    """
    Write TargetPool to YAML file.
    
    Creates a human-readable YAML file containing all targets from the pool.
    The pool's internal state is preserved (iteration position not affected).
    
    Args:
        pool: TargetPool instance to serialize
        output_dir: Directory where YAML file will be written
        filename: Name of output file (should end in .yaml)
        metadata: Optional dict of key-value pairs for header comments
    
    Returns:
        Path to the written file
    
    Raises:
        IOError: If file cannot be written
    """
    output_path = output_dir / filename
    
    # Create output directory if it doesn't exist
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Build YAML content as list of lines
    lines = []
    
    # Header with metadata as comments
    lines.append("# Generated by FATORI-V FI system")
    lines.append(f"# Timestamp: {datetime.datetime.now().isoformat()}")
    
    if metadata:
        for key, value in metadata.items():
            lines.append(f"# {key}: {value}")
    
    lines.append("")  # Blank line after header
    
    # Targets list
    lines.append("targets:")
    
    # Save current pool position so iteration doesn't affect external users
    original_pos = pool._position if hasattr(pool, '_position') else 0
    
    # Reset to iterate from beginning
    pool.reset()
    
    # Serialize each target
    target_count = 0
    while True:
        target = pool.pop_next()
        if target is None:
            break
        
        target_count += 1
        
        # Target kind (CONFIG or REG)
        lines.append(f"  - kind: {target.kind.value}")
        
        # Module name (always present)
        lines.append(f"    module_name: \"{target.module_name}\"")
        
        # Kind-specific fields
        if target.kind.value == "CONFIG":
            # Configuration bit target
            lines.append(f"    config_address: \"{target.config_address}\"")
            if target.pblock_name:
                lines.append(f"    pblock_name: \"{target.pblock_name}\"")
        
        elif target.kind.value == "REG":
            # Register target
            lines.append(f"    reg_id: {target.reg_id}")
            if target.reg_name:
                lines.append(f"    reg_name: \"{target.reg_name}\"")
        
        # Optional common fields
        if target.source:
            lines.append(f"    source: \"{target.source}\"")
        
        if target.tags:
            # Format tags as YAML list
            tags_str = ", ".join(f"\"{t}\"" for t in target.tags)
            lines.append(f"    tags: [{tags_str}]")
        
        # Blank line between targets for readability
        lines.append("")
    
    # Restore original pool position to avoid side effects
    if hasattr(pool, '_position'):
        pool._position = original_pos
    
    # Write to file
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("\n".join(lines))
        
        logger.info(f"Wrote {target_count} targets to {output_path}")
        
    except IOError as e:
        logger.error(f"Failed to write pool YAML to {output_path}: {e}")
        raise
    
    return output_path


def save_pool_with_copies(
    pool: TargetPool,
    custom_name: Optional[str],
    profile_name: str,
    board_name: str,
    output_dir: Optional[Path] = None,
    additional_path: Optional[Path] = None
) -> Dict[str, Optional[Path]]:
    """
    Save pool to primary location and optionally copy to additional path.
    
    This is the main entry point for pool export. It generates an appropriate
    filename, writes the pool to the primary output directory, and optionally
    copies it to an additional user-specified location.
    
    Args:
        pool: TargetPool to save
        custom_name: Custom filename (without extension), or None for timestamp
        profile_name: Name of area profile that generated the pool
        board_name: Board name for metadata
        output_dir: Primary output directory (default: fi/gen/tpool/)
        additional_path: Optional additional directory to copy pool to
    
    Returns:
        Dict with keys:
            - "primary": Path to primary output file
            - "copy": Path to additional copy, or None if not requested/failed
    
    Raises:
        IOError: If primary write fails (copy failures are logged but not raised)
    """
    # Use default directory if not specified
    if output_dir is None:
        output_dir = DEFAULT_OUTPUT_DIR
    else:
        output_dir = Path(output_dir)
    
    # Generate filename
    filename = generate_pool_filename(custom_name, profile_name)
    
    # Build metadata for header comments
    stats = pool.get_stats()
    metadata = {
        "Area profile": profile_name,
        "Board": board_name,
        "Total targets": str(stats['total'])
    }
    
    # Write to primary location
    primary_path = write_pool_to_yaml(pool, output_dir, filename, metadata)
    
    result = {"primary": primary_path, "copy": None}
    
    # Optional copy to additional path
    if additional_path:
        try:
            additional_path = Path(additional_path)
            additional_path.mkdir(parents=True, exist_ok=True)
            copy_path = additional_path / filename
            
            # Copy file
            shutil.copy(primary_path, copy_path)
            
            logger.info(f"Copied pool to {copy_path}")
            result["copy"] = copy_path
            
        except Exception as e:
            # Log but don't fail - primary save succeeded
            logger.error(f"Failed to copy pool to {additional_path}: {e}")
    
    return result